//----------------------------------------
//----------------- BATBOT ---------------
//----------------------------------------

#include <IRremote.h>
#include <Servo.h>
#include "TimeLib.h"

#define null 0

//----------------------------------------
//----------- IR REMOTE CODES ------------

#define IR_FORWARD 16736925
#define IR_BACK    16754775
#define IR_LEFT    16720605
#define IR_RIGHT   16761405
#define IR_STOP    16712445
#define IR_ONE     16738455
#define IR_TWO     16750695
#define IR_THREE   16756815
#define IR_FOUR    16724175
#define IR_FIVE    16718055
#define IR_SIX     16743045
#define IR_SEVEN   16716015
#define IR_EIGHT   16726215
#define IR_NINE    16734885
#define IR_ZERO    16730805
#define IR_STAR    16728765
#define IR_SHARP   16732845

//----------------------------------------
//-------------- COMMANDS ----------------

#define SET_TIME          88 // 'X'
#define SET_JOYSTICK      89 // 'Y'
#define UPARROW           70 // 'F'
#define DOWNARROW         66 // 'B'
#define RIGHTARROW        82 // 'R'
#define LEFTARROW         76 // 'L'
#define ALLSTOP           72 // 'H'
#define DO_FUNCTION_ONE   49 // '1'
#define DO_FUNCTION_TWO   50 // '2'
#define DO_FUNCTION_THREE 51 // '3'
#define DO_FUNCTION_FOUR  52 // '4'
#define DO_FUNCTION_FIVE  53 // '5'
#define DO_FUNCTION_SIX   54 // '6'
#define DO_FUNCTION_SEVEN 55 // '7'
#define DO_FUNCTION_EIGHT 56 // '8'
#define DO_FUNCTION_NINE  57 // '9'
#define DO_FUNCTION_ZERO  48 // '0'
#define DO_FUNCTION_STAR  42 // '*'
#define DO_FUNCTION_SHARP 35 // '#'

#define GAME_W            87 // 'W'
#define GAME_A            65 // 'A'
#define GAME_S            83 // 'S'
#define GAME_D            68 // 'D'
#define GAME_STOP         32 // ' '

//----------------------------------------
//-------------- HARDWARE ----------------

#define RECV_PIN   12
#define SRVO_PIN    3

#define ENB         5  // Left  wheel speed
#define IN1         7  // Left  wheel forward
#define IN2         8  // Left  wheel reverse
#define IN3         9  // Right wheel reverse
#define IN4        11  // Right wheel forward
#define ENA         6  // Right wheel speed

int Echo =         A4; // ultrasonic
int Trig =         A5; // ultrasonic

//----------------------------------------
//--------------- TIMING -----------------

#define servoAngleStart  90
#define moveFast        500
#define moveNormal      750
#define moveSlow       1000

//----------------------------------------
//-------------- DEFAULTS ----------------

#define servoDeltaRight  10
#define servoDeltaLeft  -10

//----------------------------------------
//-------------- SENSORS -----------------

//Line Tracking IO define
#define LT_R !digitalRead(10)
#define LT_M !digitalRead(4)
#define LT_L !digitalRead(2)

unsigned int lt_r, lt_m, lt_l;
unsigned int previous_lt_r, previous_lt_m, previous_lt_l;

//----------------------------------------
//--------------- CAR SPEED --------------

#define carSpeed 200  // initial speed of car >=0 to <=255
int speedDelta = 0;
char direction = ALLSTOP;

char *state    = "default";
char *motion   = "none";

//----------------------------------------
//-------------- DISTANCE ----------------

unsigned int rightDistance    = 0;
unsigned int leftDistance     = 0;
unsigned int aheadDistance    = 0;
unsigned int distance         = 0;
unsigned int previousDistance = 0;

int previousDistanceAngle     = 0;
int distanceDelta             = 3;

//----------------------------------------
//--------------- ANGLES -----------------

int servoAngle                = servoAngleStart;
int previousServoAngle        = 0;
int servoDelta                = 0; // for servoAngle movement

//----------------------------------------
//-------------- INFRA RED ---------------

IRrecv irrecv(RECV_PIN);
decode_results results;

unsigned long ir_value;

//----------------------------------------
//--------------- SERIAL -----------------

unsigned long se_value;

//----------------------------------------
//--------------- SERVO ------------------

Servo myservo; // used to control the ultrasonics servo

//----------------------------------------
//--------------- CLOCKS -----------------

#define YEAR_OFFSET          1900
#define MONTH_OFFSET            1

int adjustTimeZone            = 0; // FIXME: adjust for daylight savings time
time_t time_offset            = 0L;
time_t time_now               = 0L;

time_t curMillis              = 0L;
time_t prvMillis              = 0L;
time_t senMillis              = 0L;
time_t ircMillis              = 0L;
time_t srvMillis              = 0L;
time_t joystick               = 0L;

//----------------------------------------
//--------------- COMMAND ----------------

char *raw_cmd = null;
int cmd = 0;
long servo_movement_time; // time servo last moved

boolean have_cmd = 0;
boolean move_servo = 0;
boolean send_sensor_data = 0;
boolean read_time_value = 0;
boolean read_joystick = 0;
boolean good = 0;

//----------------------------------------
//------------ MISCELLANEOUS -------------

int servoSpeed = moveSlow;
int sensorSpeed = moveNormal;

char buffer[42];
char camera[42];
char status[64];
char number[16];

//========================================


void forward(){
  analogWrite(ENA, carSpeed + speedDelta);
  analogWrite(ENB, carSpeed + speedDelta);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void back() {
  analogWrite(ENA, carSpeed + speedDelta);
  analogWrite(ENB, carSpeed + speedDelta);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void left() {
  analogWrite(ENA, carSpeed + speedDelta);
  analogWrite(ENB, carSpeed + speedDelta);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void right() {
  analogWrite(ENA, carSpeed + speedDelta);
  analogWrite(ENB, carSpeed + speedDelta);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void stop() {
  digitalWrite(ENA, LOW);
  digitalWrite(ENB, LOW);
}

//Ultrasonic distance measurement Sub function
int getDistance() {
  digitalWrite(Trig, LOW);
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(Trig, LOW);
  return (int)pulseIn(Echo, HIGH) / 58;
}

void getDistanceUsingBounceWrapper() {
  distance = getDistance();
  if (isOutsideDelta(distance, previousDistance, distanceDelta)) {
    distance = getDistance();
    if (distance > 50000) {
      distance = getDistance();
    }
  }
}

void setup() {
  myservo.attach(SRVO_PIN);  // attach servo on pin 3 to servo object
  Serial.begin(9600);
  pinMode(Echo, INPUT);
  pinMode(Trig, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  stop();
  irrecv.enableIRIn();
  println("Ready", 1);
  delayMicroseconds(3);
}

void loop() {
  curMillis = millis();
  if ((curMillis - prvMillis) > 5000) {
    prvMillis = curMillis;
    showState();
  }
  // the IR button effects only last 1 second
  if (ircMillis != 0) {
    if (have_cmd && (curMillis - ircMillis) > 1000) {
      stop();
      have_cmd = 0;
      ircMillis = 0L;
    }
  }

  // check interrupt
  if (irrecv.decode(&results)) {
    ir_value = results.value;
    ircMillis = millis();
    irrecv.resume();
    if (ir_value != -1) {
      raw_cmd = null;
      cmd = 0;
      if (ir_value == IR_FORWARD) {
        raw_cmd = "--> IR_FORWARD";
        cmd = UPARROW;
        have_cmd = 1;
      }
      else if (ir_value == IR_BACK) {
        raw_cmd = "--> IR_BACK";
        cmd = DOWNARROW;
        have_cmd = 1;
      }
      else if (ir_value == IR_RIGHT) {
        raw_cmd = "--> IR_RIGHT";
        cmd = RIGHTARROW;
        have_cmd = 1;
      }
      else if (ir_value == IR_LEFT) {
        raw_cmd = "--> IR_LEFT";
        cmd = LEFTARROW;
        have_cmd = 1;
      }
      else if (ir_value == IR_STOP) {
        raw_cmd = "--> IR_STOP";
        cmd = ALLSTOP;
        have_cmd = 1;
      }
      else if (ir_value == IR_ONE) {
        raw_cmd = "--> IR_ONE";
        cmd = DO_FUNCTION_ONE;
        have_cmd = 1;
      }
      else if (ir_value == IR_TWO) {
        raw_cmd = "--> IR_TWO";
        cmd = DO_FUNCTION_TWO;
        have_cmd = 1;
      }
      else if (ir_value == IR_THREE) {
        raw_cmd = "--> IR_THREE";
        cmd = DO_FUNCTION_THREE;
        have_cmd = 1;
      }
      else if (ir_value == IR_FOUR) {
        raw_cmd = "--> IR_FOUR";
        cmd = DO_FUNCTION_FOUR;
        have_cmd = 1;
      }
      else if (ir_value == IR_FIVE) {
        raw_cmd = "--> IR_FIVE";
        cmd = DO_FUNCTION_FIVE;
        have_cmd = 1;
      }
      else if (ir_value == IR_SIX) {
        raw_cmd = "--> IR_SIX";
        cmd = DO_FUNCTION_SIX;
        have_cmd = 1;
      }
      else if (ir_value == IR_SEVEN) {
        raw_cmd = "--> IR_SEVEN";
        cmd = DO_FUNCTION_SEVEN;
        have_cmd = 1;
      }
      else if (ir_value == IR_EIGHT) {
        raw_cmd = "--> IR_EIGHT";
        cmd = DO_FUNCTION_EIGHT;
        have_cmd = 1;
      }
      else if (ir_value == IR_NINE) {
        raw_cmd = "--> IR_NINE";
        cmd = DO_FUNCTION_NINE;
        have_cmd = 1;
      }
      else if (ir_value == IR_ZERO) {
        raw_cmd = "--> IR_ZERO";
        cmd = DO_FUNCTION_ZERO;
        have_cmd = 1;
      }
      else if (ir_value == IR_STAR) {
        raw_cmd = "--> IR_STAR";
        cmd = DO_FUNCTION_STAR;
        have_cmd = 1;
      }
      else if (ir_value == IR_SHARP) {
        raw_cmd = "--> IR_SHARP";
        cmd = DO_FUNCTION_SHARP;
        have_cmd = 1;
      }

      if (raw_cmd != null) {
        println(raw_cmd, 1);
      }

      if (have_cmd) {
        good = execute_command(cmd);
      }
    }
  }

  // handle input from Jetson Nano
  if (Serial.available()) {

    // get the SET_TIME offset
    if (read_time_value > 0) {
      time_offset = (time_t) readPythonIntValue();
      time_now = time_offset;
      setTime(time_now);
    }

    // get the SET_JOYSTICK value
    if (read_joystick) {
      read_joystick = 0;
      joystick = (time_t) readPythonIntValue();
    }

    // read next command from jetson nano
    else {
      se_value = Serial.read();
      good = execute_command(se_value);
    }
  }

  send_sensor_data = (millis() - senMillis > sensorSpeed) ? 1 : 0;
  if (send_sensor_data) {
    transmit_sensor_data(servoSpeed);
    senMillis = millis();
  }

  // check for special run states
  if (*state != 'd') { // 'default'
    if (*state == 'm') { // 'monitor'
      function_zero();
    }
    else if (*state == 'f') { // 'following'
      function_sharp();
    }
    else if (*state == 'a') { // 'avoid'
      function_star();
    }
  }
}

uint32_t readPythonIntValue() {
  delayMicroseconds(300);
  char byte1 = 0;
  Serial.readBytes(&byte1, 1);
  char byte2 = 0;
  Serial.readBytes(&byte2, 1);
  char byte3 = 0;
  Serial.readBytes(&byte3, 1);
  char byte4 = 0;
  Serial.readBytes(&byte4, 1);
  uint32_t value = ((uint32_t)byte1 << 24) + ((uint32_t)byte2 << 16) + ((uint32_t)byte3 << 8) + (uint32_t)byte4; // big-endian
  print("VALUE READ=", 1);
  snprintf(buffer, sizeof(buffer), " %0ld ", (long) value);
  Serial.print(buffer);
  println("", 0);
  return value;
}

void setAngle(int newAngle, int newDelta) {
  servoAngle = newAngle;
  servoDelta = newDelta;
}

void incrementAngle() {
  if (servoDelta != 0) {
    servoAngle += servoDelta;
    if (servoAngle > 180) {
      servoDelta = -servoDelta;
      servoAngle = 180;
    }
    if (servoAngle < 0) {
      servoDelta = -servoDelta;
      servoAngle = 0;
    }
  }
}

void transmit_sensor_data(int servoSpeed) {
  // point the servo to the next servoAngle
  // transmit the servoAngle value
  move_servo = (millis() - srvMillis > servoSpeed) ? 1 : 0;
  if (move_servo) {
    incrementAngle();
    if (previousServoAngle != servoAngle) {
      srvMillis = millis();
      pinMode(SRVO_PIN, OUTPUT);
      println("SERVO: on", 1);
      myservo.write(servoAngle);
      print("ServoAngle=", 1);
      println(toString(servoAngle), 0);
    }
    previousServoAngle = servoAngle;
  }
  // turn the servo off when not in use
  if (srvMillis != 0L && ((millis() + 3000L) > srvMillis)) {
    srvMillis = 0L;
    pinMode(SRVO_PIN, INPUT); // the idea here is to turn off the servo when not in use.  stops shaking.
    println("SERVO: off", 1);
  }

  // transmit distance sensor value
  getDistanceUsingBounceWrapper();
  if (isOutsideDelta(distance, previousDistance, distanceDelta)
   || (servoAngle != previousDistanceAngle)) {

    if (servoAngle < 65) {
      leftDistance = distance;
      print("Distance Left=", 1);
      println(toString(leftDistance), 0);
    }
    else if (servoAngle > 115) {
      rightDistance = distance;
      print("Distance Right=", 1);
      println(toString(rightDistance), 0);
    }
    else {
      aheadDistance = distance;
      print("Distance Ahead=", 1);
      println(toString(aheadDistance), 0);
    }
    previousDistance = distance;
    previousDistanceAngle = servoAngle;
  }

  // transmit line following sensor values
  lt_r = LT_R;
  if (lt_r != previous_lt_r) {
    print("LT_R=", 1);
    println(toString(lt_r), 0);
    previous_lt_r = lt_r;
  }
  lt_m = LT_M;
  if (lt_m != previous_lt_m) {
    print("LT_M=", 1);
    println(toString(lt_m), 0);
    previous_lt_m = lt_m;
  }
  lt_l = LT_L;
  if (lt_l != previous_lt_l) {
    print("LT_L=", 1);
    println(toString(lt_l), 0);
    previous_lt_l = lt_l;
  }
}

boolean isOutsideDelta(int distance1, int distance2, int theDelta) {
  if (distance1 == distance2) {
    return 0;
  }
  else if (distance1 < distance2) {
    return ((distance1 + theDelta) < distance2);
  }
  else {
    return ((distance2 + theDelta) < distance1);
  }
}

void printdate() {
  time_now = now();
  snprintf(buffer, sizeof(buffer), "%02d/%02d/%4d %02d:%02d:%02d ", month(), day(), year(), hour() - adjustTimeZone, minute(), second());
  Serial.print(buffer);
}

void print(char *output, boolean showDate) {
  if (showDate) {
    printdate();
  }
  Serial.print(output);
}

void println(char *output, boolean showDate) {
  if (showDate) {
    printdate();
  }
  Serial.println(output);
}

char * toString(unsigned long num) {
  snprintf(number, sizeof(number), "%ld", num);
  return number;
}

boolean execute_command(int cmd) {
  boolean valid = 0;
  if (cmd != 0) {
    print("got cmd=", 1);
    println(toString(cmd), 0);
    switch(cmd) {
      case SET_TIME:
        valid = function_set_time();
        break;
      case SET_JOYSTICK:
        valid = function_set_joystick();
        break;
      case UPARROW:
      case GAME_W:
        valid = function_up();
        break;
      case DOWNARROW:
      case GAME_S:
        valid = function_down();
        break;
      case LEFTARROW:
      case GAME_A:
        valid = function_left();
        break;
      case RIGHTARROW:
      case GAME_D:
        valid = function_right();
        break;
      case ALLSTOP:
      case GAME_STOP:
        valid = function_ok();
        break;
      case DO_FUNCTION_ONE:
        valid = function_one();
        break;
      case DO_FUNCTION_TWO:
        valid = function_two();
        break;
      case DO_FUNCTION_THREE:
        valid = function_three();
        break;
      case DO_FUNCTION_FOUR:
        valid = function_four();
        break;
      case DO_FUNCTION_FIVE:
        valid = function_five();
        break;
      case DO_FUNCTION_SIX:
        valid = function_six();
        break;
      case DO_FUNCTION_SEVEN:
        valid = function_seven();
        break;
      case DO_FUNCTION_EIGHT:
        valid = function_eight();
        break;
      case DO_FUNCTION_NINE:
        valid = function_nine();
        break;
      case DO_FUNCTION_ZERO:
        valid = function_zero();
        break;
      case DO_FUNCTION_STAR:
        valid = function_star();
        break;
      case DO_FUNCTION_SHARP:
        valid = function_sharp();
        break;
    }
  }
  return valid;
}

//-----------------------------------------------------------------
// CUSTOM IR-REMOTE and SERIAL COMMANDS

boolean function_set_time() {
  read_time_value = 1;
  //println("fn_set_time: do set", 1);
  return 1;
}

boolean function_set_joystick() {
  read_joystick = 1;
  //println("fn_set_joystick: do set", 1);
  return 1;
}

boolean function_up() {
  forward();
  motion = "forward";
  direction = UPARROW;
  println("fn_up: go forward", 1);
  return 1;
}

boolean function_left() {
  left();
  motion = "left";
  direction = LEFTARROW;
  println("fn_left: go left", 1);
  return 1;
}

boolean function_right() {
  right();
  motion = "right";
  direction = RIGHTARROW;
  println("fn_right: go right", 1);
  return 1;
}

boolean function_down() {
  back();
  motion = "down";
  direction = DOWNARROW;
  println("fn_down: go back", 1);
  return 1;
}

// reset to defaults
boolean function_ok() {
  stop();
  direction = ALLSTOP;
  state = "default";
  motion = "none";
  speedDelta = 0;
  servoDelta = 0;
  println("fn_ok: STOP", 1);
  return 1;
}

// look right
boolean function_one() {
  setAngle(45, 0);
  println("fn_one: look toward left", 1);
  return 1;
}

// look ahead
boolean function_two() {
  setAngle(90, 0);
  println("fn_two: look ahead", 1);
  return 1;
}

// look left
boolean function_three() {
  setAngle(90 + 45, 0);
  println("fn_three: look toward right", 1);
  return 1;
}

// look full right
boolean function_four() {
  setAngle(0, 0);
  println("fn_four: look full left", 1);
  return 1;
}

// map your world
boolean function_five() {
  // FIXME
  println("fn_five: 'map'", 1);
  return 1;
}

// look full left
boolean function_six() {
  setAngle(180, 0);
  println("fn_six: look full right", 1);
  return 1;
}

// go slower
boolean function_seven() {
  if ((carSpeed + speedDelta) >= 170) {
     speedDelta -= 3;
  }
  else {
    println("-limit", 1);
  }
  print("fn_seven: (slower) speed=", 1);
  print(toString(carSpeed + speedDelta), 0);
  return 1;
}

// sensors: return all sensor and status data
boolean function_eight() {
  println("fn_eight: 'sensors'", 1);
  print("Last Distance: ", 1);
  println(toString(distance), 0);
  print("Ahead Distance: ", 1);
  println(toString(aheadDistance), 0);
  print("Left Distance: ", 1);
  println(toString(leftDistance), 0);
  print("Right Distance: ", 1);
  println(toString(rightDistance), 0);
  print("LT_R: ", 1);
  println(toString(lt_r), 0);
  print("LT_M: ", 1);
  println(toString(lt_m), 0);
  print("LT_L: ", 1);
  println(toString(lt_l), 0);
  print("Throttle: ", 1);
  println(toString(carSpeed + speedDelta), 0);
  snprintf(camera, sizeof(camera), "Camera Angle: %d, Motion: %d ", servoAngle, servoDelta);
  println(camera, 1);
  showState();
  return 1;
}

void showState() {
  char *dir = "";
  if (direction == ALLSTOP) {
    dir = "STOP";
  }
  if (direction == UPARROW) {
    dir = "AHEAD";
  }
  else if (direction == DOWNARROW) {
    dir = "BACK";
  }
  else if (direction == RIGHTARROW) {
    dir = "RIGHT";
  }
  else if (direction == LEFTARROW) {
    dir = "LEFT";
  }
  snprintf(status, sizeof(status), "State: %s %s, Joystick: %s %d", state, motion, dir, (int) joystick);
  println(status, 1);
}

// go faster
boolean function_nine() {
  if ((carSpeed + speedDelta) <= 250) {
    speedDelta += 3;
  }
  else {
    println("+limit", 1);
  }
  print("fn_nine: (faster) speed=", 1);
  print(toString(carSpeed + speedDelta), 0);
  return 1;
}

// run security monitor protocol
boolean function_zero() {
  if (state != 'm') {
    state = "monitor";
    println("fn_zero: 'monitor'", 1);
  }
  // FIXME
  return 1;
}

// run Elegoo collision avoidance
boolean function_star() {
  if (*state != 'a') {
    state = "avoid";
    println("fn_star: 'avoid'", 1);
  }
  // FIXME
  return 1;
}

// run Elegoo line following
boolean function_sharp() {
  if (*state != 'f') {
    state = "following";
    println("fn_sharp: 'following'", 1);
  }
  // FIXME
  return 1;
}

